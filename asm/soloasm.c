/**********************************************************************
axasm Copyright 2006, 2007, 2008, 2009 
by Al Williams (alw@al-williams.com).


This file is part of axasm.

axasm is free software: you can redistribute it and/or modify it
under the terms of the GNU General Public Licenses as published
by the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

axasm is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY: without even the implied warranty of 
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with axasm (see LICENSE.TXT). 
If not, see http://www.gnu.org/licenses/.

If a non-GPL license is desired, contact the author.

This is the retargetable assembler core file

***********************************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <getopt.h>
#include <libgen.h>
#include <string.h>
#define _SOLO_MAIN
#include "soloasm.h"

// axasm requires strict C99 standard compatibility, where strdup is not part of
// However, it can be successfully linked to GNU glibc with the following extern declaration
extern char* strdup(const char *s);

extern unsigned genasm(unsigned);

static FILE *outfile;

int main(int argc, char *argv[])
{
  unsigned int endmem,i,j;
  unsigned int siz;
  unsigned mask;
  int opt=0;
  int mode=0;
  char *bname = strdup("stdout");
  outfile=stdout;
  while (opt!=-1)
    {
      opt=getopt(argc,argv,"b8vhixlco:");
      switch (opt)
	{
  case 'c':
    mode=7;  // C header file mode
    break;
  case 'l':
    mode=6;  // VHDL init file mode
    break;
	case '8':
	  mode=5;  // 8 bit binary mode
	  break;
	case 'b':
	  mode=4;
	  break;
	case 'v':
	  mode=3;
	  break;
	case 'i':
	  mode=2;
	  break;
	case 'x':
	  mode=1;
	  break;
	case 'h':
	  mode=0;
	  break;

	case 'o':
	  // note -b must be before -o 
	  outfile=fopen(optarg,mode==4?"r+":"w");
	  if (!outfile) 
	    {
	      perror(optarg);
	      return 1;
	    }
    free(bname);
    bname = strdup(optarg);
	  break;
	}
    }
  _solo_info.psize=32;   //default size
  endmem=genasm(1); // let labels get filled in
  if (_solo_info.err==0) endmem=genasm(2); // pass 2 for real
  if (_solo_info.err!=0) 
    {
      fprintf(stderr,"Fatal error. No output generated.\n");
      return 1;
    }
  siz=_solo_info.psize;
  switch (mode)
    {
    case 1:
      fprintf(outfile,";Generated by soloasm\n");
      fprintf(outfile,"MEMORY_INITIALIZATION_RADIX=16;\n");
      fprintf(outfile,"MEMORY_INITIALIZATION_VECTOR=\n");
      for (i=_solo_info.begin;i<=_solo_info.end;i++) fprintf(outfile,"%0*X%c\n",siz/4,_solo_info.ary[i],i==_solo_info.end?';':',');
      break;
    case 2:  // basic 64k intel hex file only; psize must be multiple of 8
      mask=0xFF;
      unsigned bytesper=16/(siz/8);
      for (i=_solo_info.begin;i<=_solo_info.end;i+=bytesper)
	{
	  /* need to compute # of output words on this line */
	  unsigned bsize;
	  unsigned lsize=bytesper;  // nominal line size (round up)
	  if (i+lsize>_solo_info.end) 
	      lsize=(_solo_info.end-i)+1;
	  bsize=lsize*bytesper;
	  unsigned csum=lsize+(i>>8)+(i&0xFF);
	  unsigned byt;
	  fprintf(outfile,":");
          fprintf(outfile,"%02x%04x00",bsize,i);
	  for (j=0;j<lsize;j++)
	    {
	      fprintf(outfile,"%02x",_solo_info.ary[i+j]&mask);
	      csum+=_solo_info.ary[i+j]&mask;
	      if (siz>8) 
		{
		  fprintf(outfile,"%02x",byt=(_solo_info.ary[i+j]>>8)&mask);
		  csum+=byt;
		}
	      if (siz>16)
		{
		  fprintf(outfile,"%02x",byt=(_solo_info.ary[i+j]>>16)&mask);
		  csum+=byt;
		}
	      if (siz>24)
		{
		  fprintf(outfile,"%02x",byt=(_solo_info.ary[i+j]>>24)&mask);
		  csum+=byt;
		}
	    }
	  fprintf(outfile,"%02x\n",((~csum)+1)&0xFF);
	}
      fprintf(outfile,":00000001FF\n");
      break;
    case 4:   // binary for 32 bit targets only (arch dependent)
      fseek(outfile,_solo_info.begin,SEEK_SET);
      fwrite(_solo_info.ary+_solo_info.begin,1,(_solo_info.end+1-_solo_info.begin)*(siz/8),outfile);
      break;
    case 5:
      fseek(outfile,_solo_info.begin,SEEK_SET);
      for (int i=_solo_info.begin;i<=_solo_info.end;i++)
	fputc(_solo_info.ary[i],outfile);
      break;
      
    case 6: ; // VHDL init file output
      char *bname2   = basename(bname);
      char *bnamedot = strrchr(bname2,'.');
      if(bnamedot) *bnamedot = '\0';
      fprintf(outfile,"-- Auto-generated by soloasm\n\n");
      fprintf(outfile,"library ieee;\n");
      fprintf(outfile,"use ieee.std_logic_1164.all;\n\n");
      fprintf(outfile,"package %s is\n\n",bname2);
      fprintf(outfile,"  type image_t is array (0 to %u) of std_logic_vector(%u downto 0);\n",_solo_info.memsize,siz-1);
      fprintf(outfile,"  constant init_image : image_t := (\n");
      for (i=_solo_info.begin;i<=_solo_info.end;i++) {
        fprintf(outfile,"    %06u => x\"%0*x\",\n",i,(siz+3)/4,_solo_info.ary[i]);
      }
      fprintf(outfile,"    others => x\"%0*x\"\n",(siz+3)/4,0);
      fprintf(outfile,"  );\n\n");
      fprintf(outfile,"end %s;\n",bname2);
      break;
      
    case 7:   // C header file output
      fprintf(outfile,"//Generated by soloasm\n");
      fprintf(outfile,"const unsigned int imem_image[%u] = {\n",_solo_info.end+1-_solo_info.begin);
      for (i=_solo_info.begin;i<=_solo_info.end;i+=16) {
        for (j=0;j<16;j++) if (i+j<=_solo_info.end)
          fprintf(outfile,"%3u%c ",_solo_info.ary[i+j],i+j==_solo_info.end?' ':',');
        fprintf(outfile,"\n");
      }
      fprintf(outfile,"};\n");
      break;
      
    default:  // including mode=0;
      if (mode==3) fprintf(outfile,"@%X ",_solo_info.begin);	    
      for (i=_solo_info.begin;i<=_solo_info.end;i+=16)
	{
	  if (mode!=3 && mode!=0)fprintf(outfile,"%0*X: ",siz==8?4:8,i);
	  for (j=0;j<16;j++) 
	    if (i+j<=_solo_info.end) 
	      {
		if (mode==0) fprintf(outfile,"%0*X: ",siz==8?4:8,i+j);
        // !! changed for MEH ASIC flashloader with 8 bit load, load 2 4-bit instructions parallel !!
	      //fprintf(outfile,"%0*X ",(siz+3)/4,_solo_info.ary[i+j]); 
        #ifdef INIT
        fprintf(outfile,"%0*X ",(siz+3)/4,_solo_info.ary[i+j]); 
        #else
        if(!(j&1)) fprintf(outfile,"%0*X ",(siz+3)/4,(_solo_info.ary[i+j+1]&15)|((_solo_info.ary[i+j]&15)<<4)); 
        #endif
        // !! change end !!
	      if (mode==0) fprintf(outfile,"\n");
	      }
	  if (mode!=0) fprintf(outfile,"\n");
	}
    }
  
  if (outfile!=stdout) fclose(outfile);
  free(bname);
  return 0;
}

